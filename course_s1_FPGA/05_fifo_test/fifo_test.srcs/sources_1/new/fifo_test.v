`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
module fifo_test
    (
        input       clk,             // 25MHz 시스템 클럭 (25MHz system clock)
        input       rst_n            // 리셋 신호, Low 활성 (reset signal, active low)
    );


reg  [15:0]      w_data          ;        // FIFO 쓰기 데이터 (FIFO write data)
wire             wr_en           ;        // FIFO 쓰기 인에이블 (FIFO write enable)
wire             rd_en           ;        // FIFO 읽기 인에이블 (FIFO read enable)
wire [15:0]      r_data          ;        // FIFO 읽기 데이터 (FIFO read data)
wire             full            ;        // FIFO 풀 플래그 (FIFO full flag)
wire             empty           ;        // FIFO 엠티 플래그 (FIFO empty flag)
wire [8:0]       rd_data_count   ;        // 읽을 수 있는 데이터 개수 (number of readable data words)
wire [8:0]       wr_data_count   ;        // 지금까지 쓴 데이터 개수 (number of written data words)

wire             clk_100M        ;        // PLL이 생성한 100MHz 클럭 (100MHz clock generated by PLL)
wire             clk_75M         ;        // PLL이 생성한 75MHz 클럭 (75MHz clock generated by PLL)
wire             locked          ;        // PLL lock 신호, 시스템 리셋으로 사용, High면 lock 상태 (PLL lock signal, used as system reset source, high means locked)
wire             fifo_rst_n      ;        // FIFO 리셋, Low 활성 (FIFO reset signal, active low)

wire             wr_clk          ;        // FIFO 쓰기 클럭 (write clock for FIFO)
wire             rd_clk          ;        // FIFO 읽기 클럭 (read clock for FIFO)
reg [7:0]        wcnt            ;        // 쓰기측 리셋 후 대기 카운터 (wait counter after reset for write side)
reg [7:0]        rcnt            ;        // 읽기측 리셋 후 대기 카운터 (wait counter after reset for read side)

wire             clkbuf          ;

   BUFG BUFG_inst (
      .O(clkbuf), // 전역 버퍼 출력 클럭 (global buffered clock output)
      .I(clk)     // 보드 입력 클럭 (board input clock)
   );


// PLL 인스턴스: 25MHz → 100MHz, 75MHz 클럭 생성
// Instantiate PLL to generate 100MHz and 75MHz clocks from 25MHz
clk_wiz_0 fifo_pll
 (
  // Clock out ports
  .clk_out1(clk_100M),          // 100MHz 출력 클럭 (100MHz output clock)
  .clk_out2(clk_75M),           // 75MHz 출력 클럭 (75MHz output clock)
  // Status and control signals
  .reset(~rst_n),               // PLL 리셋, High 활성 (PLL reset, active high)
  .locked(locked),              // PLL lock 플래그 (PLL lock flag)
  // Clock in ports
  .clk_in1(clkbuf)              // PLL 입력 클럭 (PLL input clock)
  );

assign fifo_rst_n  = locked ;   // PLL LOCK 신호를 FIFO 리셋으로 사용 (use PLL LOCK as FIFO reset, active low inside)
assign wr_clk      = clk_100M ; // 100MHz를 쓰기 클럭으로 사용 (use 100MHz as write clock)
assign rd_clk      = clk_75M  ; // 75MHz를 읽기 클럭으로 사용 (use 75MHz as read clock)


/* 쓰기 FSM (Write FIFO state machine) */
localparam      W_IDLE      = 1 ;
localparam      W_FIFO      = 2 ;

reg[2:0]  write_state;
reg[2:0]  next_write_state;

always@(posedge wr_clk or negedge fifo_rst_n)
begin
    if(!fifo_rst_n)
        write_state <= W_IDLE;
    else
        write_state <= next_write_state;
end

always@(*)
begin
    case(write_state)
        W_IDLE:
            begin
                // 리셋 후 일정 시간 대기, safety circuit 모드에서 가장 느린 클럭 기준 60주기 (약 80주기) 대기
                // wait some cycles after reset; in safety circuit mode wait ~60 cycles of slowest clock (~80 cycles here)
                if(wcnt == 8'd79)
                    next_write_state <= W_FIFO;
                else
                    next_write_state <= W_IDLE;
            end
        W_FIFO:
            // 계속 FIFO 쓰기 상태 유지 (stay in write-FIFO state continuously)
            next_write_state <= W_FIFO;
        default:
            next_write_state <= W_IDLE;
    endcase
end

// IDLE 상태(리셋 직후)에서 대기 카운터 증가
// In IDLE state (just after reset), increase wait counter
always@(posedge wr_clk or negedge fifo_rst_n)
begin
    if(!fifo_rst_n)
        wcnt <= 8'd0;
    else if (write_state == W_IDLE)
        wcnt <= wcnt + 1'b1 ;
    else
        wcnt <= 8'd0;
end

// 쓰기 상태에서, FIFO가 가득 차지 않았으면 계속 쓰기 (if not full, keep writing to FIFO)
assign wr_en = (write_state == W_FIFO) ? ~full : 1'b0;

// wr_en 유효 시, 쓰기 데이터 값을 1씩 증가 (when write enable is high, increment write data)
always@(posedge wr_clk or negedge fifo_rst_n)
begin
    if(!fifo_rst_n)
        w_data <= 16'd1;
    else if (wr_en)
        w_data <= w_data + 1'b1;
end

/* 읽기 FSM (Read FIFO state machine) */

localparam      R_IDLE      = 1 ;
localparam      R_FIFO      = 2 ;

reg[2:0]  read_state;
reg[2:0]  next_read_state;

/// FIFO 읽기 제어용 상태 생성 (generate states for FIFO read control)
always@(posedge rd_clk or negedge fifo_rst_n)
begin
    if(!fifo_rst_n)
        read_state <= R_IDLE;
    else
        read_state <= next_read_state;
end

always@(*)
begin
    case(read_state)
        R_IDLE:
            begin
                // 리셋 후 일정 시간 대기, safety circuit 모드에서 가장 느린 클럭 기준 60주기 대기
                // wait some cycles after reset; in safety circuit mode wait 60 cycles of slowest clock
                if (rcnt == 8'd59)
                    next_read_state <= R_FIFO;
                else
                    next_read_state <= R_IDLE;
            end
        R_FIFO:
            // 계속 FIFO 읽기 상태 유지 (stay in read-FIFO state continuously)
            next_read_state <= R_FIFO ;
        default:
            next_read_state <= R_IDLE;
    endcase
end

// IDLE 상태(리셋 직후)에서 읽기측 대기 카운터 증가
// In IDLE state (just after reset), increase read-side wait counter
always@(posedge rd_clk or negedge fifo_rst_n)
begin
    if(!fifo_rst_n)
        rcnt <= 8'd0;
    else if (write_state == W_IDLE)
        rcnt <= rcnt + 1'b1 ;
    else
        rcnt <= 8'd0;
end

// 읽기 상태에서, FIFO가 비어 있지 않으면 계속 읽기 (if not empty, read data from FIFO)
assign rd_en = (read_state == R_FIFO) ? ~empty : 1'b0;

//-----------------------------------------------------------
// FIFO 인스턴스화 (Instantiate FIFO)
fifo_ip fifo_ip_inst
(
  .rst            (~fifo_rst_n     ),   // FIFO 리셋, High 활성 (FIFO reset, active high)
  .wr_clk         (wr_clk          ),   // 쓰기 클럭 (write clock)
  .rd_clk         (rd_clk          ),   // 읽기 클럭 (read clock)
  .din            (w_data          ),   // 쓰기 데이터 입력 [15:0] (write data input [15:0])
  .wr_en          (wr_en           ),   // 쓰기 인에이블 (write enable)
  .rd_en          (rd_en           ),   // 읽기 인에이블 (read enable)
  .dout           (r_data          ),   // 읽기 데이터 출력 [15:0] (read data output [15:0])
  .full           (full            ),   // 풀 플래그 (full flag)
  .empty          (empty           ),   // 엠티 플래그 (empty flag)
  .rd_data_count  (rd_data_count   ),   // 읽을 수 있는 데이터 개수 [8:0] (readable data count [8:0])
  .wr_data_count  (wr_data_count   )    // 쓴 데이터 개수 [8:0] (written data count [8:0])
);

// 쓰기 채널 ILA 인스턴스 (ILA for write channel)
ila_m0 ila_wfifo (
    .clk        (wr_clk         ),
    .probe0     (w_data         ),    // 쓰기 데이터 (write data)
    .probe1     (wr_en          ),    // 쓰기 인에이블 (write enable)
    .probe2     (full           ),    // 풀 플래그 (full flag)
    .probe3     (wr_data_count  )     // 쓰기 데이터 카운트 (write data count)
);

// 읽기 채널 ILA 인스턴스 (ILA for read channel)
ila_m0 ila_rfifo (
    .clk        (rd_clk         ),
    .probe0     (r_data         ),    // 읽기 데이터 (read data)
    .probe1     (rd_en          ),    // 읽기 인에이블 (read enable)
    .probe2     (empty          ),    // 엠티 플래그 (empty flag)
    .probe3     (rd_data_count  )     // 읽기 데이터 카운트 (read data count)
);

endmodule